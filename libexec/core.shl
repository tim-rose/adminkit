#!/bin/sh
#
# CORE.SHL --Shell Library of core functions.
#
# Contents:
# require()       --load some files once-only.
# resolve_path()  --Find a file in a path-specific way.
# quietly()       --Run a command, but dump stdout+stderr.
# match()         --Test if a string matches a pattern.
# choose()        --Interactively filter a set of values.
# prompt()        --Prompt for a value, with a default.
# prompt_ok()     --Prompt for a value and return.
# vcs_keyword()   --Reformat a VCS Id string into something more presentable.
# is_user()       --Test if the current process is ownded by a specified user.
# is_group()      --Test if the current process is a member of a specified group.
# argv_or_stdin() --output arguments (if specified) or lines from stdin.
# mk_dir()        --create a directory, and log about it too...
#
# Remarks:
# This library contains miscellaneous routines that I don't have
# another/better place for.
#

case "$shl_loaded" in *:core.shl:*) return 0;; esac
shl_loaded=:core.shl:		# we're loaded!

#
# require() --load some files once-only.
#
# Remarks:
# the variable "shl_loaded" is used to track whether a file has been loaded.
#
require()
{
    local library=
    for library in "$@"; do
	if ! match "$shl_loaded" "*:$library:*"; then
	    . "$library" && shl_loaded="$shl_loaded:$library:"
	fi
    done
}

#
# resolve_path() --Find a file in a path-specific way.
#
# Parameters:
# path	--the path to search (optional, default: $PATH )
# file	--the file 
#
resolve_path()
(				# run in a sub-shell (b/c set IFS)
    local path=

    if [ $# -eq 2 ]; then
	path=$1
	shift
    else
	path=$PATH
    fi
    IFS=:
    for dir in $path; do
	for target in $dir/$1; do	# handle globs
    	    if [ -f "$target" ]; then
		echo $target
		return 0
	    fi
	    break
	done
    done
    return 1
)

#
# quietly() --Run a command, but dump stdout+stderr.
#
quietly()
{
    "$@"
} >/dev/null 2>&1

#
# match() --Test if a string matches a pattern.
#
# Parameters:
# $1	--the string to test
# $2	--the target pattern
#
# Returns:
# Success: true; Failure: false
#
match() 
{ 
    case "$1" in 
    $2) return 0;; 
    esac
    return 1
}

#
# choose() --Interactively filter a set of values.
#
# Parameters:
# $@	--this list of words to choose from
#
# Returns:
# Success: true (and prints the chosen words); Failure: false.
#
# Remarks:
# This is similar to the bash "select" command.
#
choose()
{				# run in a sub-shell to localise var.s
    local list=
    local all=
    local choice=

    for file in "$@"; do
	while true; do
	    if [ "$all" ]; then
		choice=y
	    else
		read -n1 -p "$file? [ynaq]: " choice
		echo;			# get to a newline
	    fi
	    if match $choice [yYnNaAqQ]; then
		break;
	    else
		echo "Please type y(=yes) n(=no) a(=all remaining) q(=quit, none selected)" >&2
	    fi
	done
	case $choice in
	[yY])	list="$list $file";;
	[nN])	;;
	[aA])	list="$list $file"; all=1;;
	[qQ])	return 1;;	# failure
	esac
    done
    if [ "$list" ]; then
	echo $list
    fi
    return 0
}

#
# prompt() --Prompt for a value, with a default.
#
# Parameters:
# $1	--the prompt
# $2	--the default value
#
# Returns:
# Success: true, and echoes the new value; Failure: false
#
prompt()
{
    local read_opts=

    if [ "$BASH" ]; then
	read_opts=-e		# bash supports readline
    fi
    if [ "$2" ]; then
	prompt_text="$1[$2]: "
    else
	prompt_text="$1: "
    fi
    if read $read_opts -p "$prompt_text" value; then
	if [ "$value" ]; then
	    echo $value
	else
	    echo $2			# default
	fi
	return 0
    fi
    return 1
}

#
# prompt_ok() --Prompt for a value and return.
#
prompt_ok()
{
    local response=$(prompt "$@") || return 1

    case $response in
	[yY]*)	return 0;;
	*)	;;
    esac
    return 1
}

#
# vcs_keyword() --Reformat a VCS Id string into something more presentable.
#
# Parameter:
# $1	--an VCS keyword string compatible with SVN's "Id" expansion
#
# Remarks:
# The parameter should match something like:
#     "$Id: core.shl 2643 2011-05-05 01:22:56Z tar $'
# REVISIT: this is specific to RCS,CVS,SVN
#
vcs_keyword()
{
    if [ ! "$1" ]; then return; fi
    echo "$1" |
    if read vcs_keyword vcs_name vcs_id \
	vcs_date vcs_time vcs_user vcs_end; then
        printf '%s@%d (built: %s %s)\n' $vcs_name $vcs_id $vcs_date $vcs_time
    fi
}

#
# is_user() --Test if the current process is ownded by a specified user.
#
is_user()
{
    local target_user=$(grep "^$1:" /etc/passwd | cut -d: -f3)

    test $(id -nu $1 2>/dev/null) = "$1"
}

#
# is_group() --Test if the current process is a member of a specified group.
#
is_group()
{
    for group in $(id -Gn); do
	if [ "$group" = "$1" ]; then
	    return 0			# success:
	fi
    done
    return 1				# failure: not found
}

#
# argv_or_stdin() --output arguments (if specified) or lines from stdin.
#
argv_or_stdin()
{
    local arg
    if [ $# -gt 0 ]; then
	for arg; do echo "$arg"; done 
    else
	while read arg; do echo "$arg"; done
    fi
}

#
# mk_dir() --create a directory, and log about it too...
#
mk_dir() 
{
    for dir; do
	if [ ! -d $dir ]; then
	    info 'creating directory %s' $dir
	    if ! install -d $dir; then
		notice '%s: failed to create directory'
	    fi
	fi
    done
}
