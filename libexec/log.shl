#!/bin/sh
#
# LOG.SHL --Shell Library code for logging to stderr/syslog.
#
# Contents:
# _log_init()         --Initialise variables used to render stderr messages.
# _log_level_number() --Return the numeric code for a log level.
# _log_level_name()   --Return the textual name for a log level.
# _log_level_color()  --Return the rendering color for a log level.
# _log_context()      --Return a "context" line that includes the severity.
# log_msg()           --Log a message to stderr or syslog.
# log_quit()          --Log a message and quit.
# emerg()             --Log an emergency message.
# log_getopts()       --Set the logging options based on variables set by LOG_GETOPTS.
# log_cmd()           --Log a command and then run it.
# log_var()           --Log the value of some variables
#
# Remarks:
# This library provides some customisation over logging facilities that
# allows a program to log to either stderr or syslog, with some filtering
# based on the "log level".
#
. core.shl
#
# We define some variables here that control the default behaviour
# of the logging system.  Note that they are exported, so that they
# will be honoured by sub-processes.
#
export LOG_OUTPUT; LOG_OUTPUT=${LOG_OUTPUT:-stderr}
export LOG_LEVEL; LOG_LEVEL=${LOG_LEVEL:-notice}
export LOG_FACILITY; LOG_FACILITY=${LOG_FACILITY:-user}
USER=${USER:-$LOGNAME}
USER=${USER:-nobody}
export LOG_IDENT; LOG_IDENT=$USER
export LOG_COLORS=${LOG_COLORS:-LOG_COLORS=debug=36:notice=1:warning=1;33:err=1;31:crit=1;33;41:alert=1;5;33;41:emerg=1;5;37;41}
#export LOG_TIMESTAMP; LOG_TIMESTAMP='%b %d %H:%M:%S'
LOG_GETOPTS="q.quiet;v.verbose;_.debug" # Note: not exported!
LOG_PID=$$				# Note: not exported!
_log_status=1				# exit status for log_quit

#need caller	# TODO: handle this need better...

#
# log_init() --Initialise variables used to render stderr messages.
#
# Remarks:
# If the current stderr is not a tty, the variables remain undefined.
# The stderr-reporting logic relies on this.
#
log_init()
{
    if [ "$(tty <&2)" != "not a tty" ]; then
	local IFS=:
	for level in $LOG_COLORS; do
	    echo $level | sed -e 's/^/log_attr_/' -e 's/=/="/' -e 's/$/"/'
	done
    fi
}
eval $(log_init)		# apply/import the variable definitions...

#
# log_level_number() --Return the numeric code for a log level.
#
log_level_number()
{
    case $1 in
    7|emerg)	echo 7;;
    6|alert)	echo 6;;
    5|crit)	echo 5;;
    4|err)	echo 4;;
    3|warning)	echo 3;;
    2|notice)	echo 2;;
    1|info)	echo 1;;
    0|debug)	echo 0;;
    *)		echo 7;;
    esac
}

#
# log_level_name() --Return the textual name for a log level.
#
log_level_name()
{
    case $1 in
    7|emerg)	echo 'emerg';;
    6|alert)	echo 'alert';;
    5|crit)	echo 'crit';;
    4|err)	echo 'err';;
    3|warning)	echo 'warning';;
    2|notice)	echo 'notice';;
    1|info)	echo 'info';;
    0|debug)	echo 'debug';;
    *)		echo 'unknown';;
    esac
}

#
# log_level_color() --Return the rendering color for a log level.
#
log_level_color()
{
    case $1 in
    7|emerg)	echo $log_attr_emerg;;
    6|alert)	echo $log_attr_alert;;
    5|crit)	echo $log_attr_crit;;
    4|err)	echo $log_attr_err;;
    3|warning)	echo $log_attr_warning;;
    2|notice)	echo $log_attr_notice;;
    1|info)	echo $log_attr_info;;
    0|debug)	echo $log_attr_debug;;
    esac
}

#
# log_context() --Return a "context" line that includes the severity.
#
# Parameter:
# $1	--the severity
#
# Remarks:
# This only works for bash!
#
log_context()
{
    caller 2 | sed -e "s/\([^ ]*\) *\([^ ]*\) *\(.*\)/\2:\3:\1: $1:/"
}

#
# log_msg() --Log a message to stderr or syslog.
#
# Parameters:
# $1	--the priority at which to log
# ...	--the message as printf(1) arguments
#
# Remarks:
# In addition to printing the message, this code adds some prefix
# information to make the output a little more consistent and easy
# to process.  In particular, the priority of the message is printed,
# with a prefix that can include the date of the message.
#
# Note that to simulate syslog's date format, set LOG_TIMESTAMP
# to '%b %d %H:%M:%S'.
#
# TODO: add support of logger(1)-style stdin handling
#
log_msg()
{
    local log_level=$(log_level_number $1)

    if [ $log_level -lt $(log_level_number $LOG_LEVEL) ]; then
	return;
    fi

    local log_priority=$(log_level_name $1); shift
    local log_prefix=

    if [ "$1" = '-c' ]; then
	shift;				# provide developer context
	log_prefix=$(log_context $log_priority)
    fi
    if [ ! "$log_prefix" ]; then
	log_prefix="$log_priority:"
    fi

    if [ $# -eq 1 ]; then
	local log_msg="$1"
    else
	local log_msg=$(printf "$@")
    fi

    local IFS=:
    for output in $LOG_OUTPUT; do
	case "$output" in
        syslog)
	    logger -t "${LOG_IDENT}[$LOG_PID]" \
		-p ${LOG_FACILITY}.${log_priority} \
		"$log_prefix $log_msg"
	    ;;
	stderr)			# stderr, with colours
	    if [ "$LOG_TIMESTAMP" ]; then
		log_prefix="$(date "+$LOG_TIMESTAMP") $log_prefix"
	    fi
	    log_color=$(log_level_color $log_level)
	    if [ "$log_color" ]; then
		printf "\033[%sm%s\033[m\n" \
		    $log_color "$log_prefix $log_msg" >&2
	    else
		echo "$log_prefix $log_msg" >&2
	    fi
	    ;;
	xterm)
	    printf "\033]0;%s\007" "$log_msg" >/dev/tty # icon+title
	    ;;
	growl)
	    #
	    # growl is a Mac-only system, but there are similar systems for
	    # Linux (gnotify?) and Windows (???)
	    #
	    log_level=$((5 - $log_level))	# adjust log-level for growl...
	    if [ $log_level -gt 2 ]; then
		log_level=2
	    fi
	    log_growl_opts="-p $log_level -d $LOG_IDENT"
	    if [ "$LOG_ICON" ]; then
		log_growl_opts="$log_growl_opts -a $LOG_ICON"
	    fi
	    growlnotify $log_growl_opts -m "$log_msg" "$LOG_IDENT $log_priority"
	    ;;
	esac
    done
}

#
# log_quit() --Log a message and quit.
#
log_quit()
{
    log_msg err "$@"
    exit $log_status
}

#
# emerg() --Log an emergency message.
#
emerg()   { log_msg emerg   "$@"; }
alert()   { log_msg alert   "$@"; }
crit()    { log_msg crit    "$@"; }
err()     { log_msg err     "$@"; }
warning() { log_msg warning "$@"; }
notice()  { log_msg notice  "$@"; }
info()    { log_msg info    "$@"; }
debug()   { log_msg debug   "$@"; }

trace_emerg()   { log_msg emerg -c   "$@"; }
trace_alert()   { log_msg alert -c   "$@"; }
trace_crit()    { log_msg crit -c    "$@"; }
trace_err()     { log_msg err -c     "$@"; }
trace_warning() { log_msg warning -c "$@"; }
trace_notice()  { log_msg notice -c  "$@"; }
trace_info()    { log_msg info -c    "$@"; }
trace_debug()   { log_msg debug -c   "$@"; }

#
# log_getopts() --Set the logging options based on variables set by LOG_GETOPTS.
#
# Remarks:
# This routine assumes that script-variables have been set via the getopts
# system, using the LOG_GETOPTS definition.
# 
log_getopts()
{
    if [ "$quiet" ];   then LOG_LEVEL=warning; fi
    if [ "$verbose" ]; then LOG_LEVEL=info; fi
    if [ "$debug" ];   then LOG_LEVEL=debug; fi
}

#
# log_cmd() --Log a command and then run it.
#
log_cmd()
{
    debug "exec: $*"; "$@"
}

#
# log_var() --Log the value of some variables
#
log_var()
{
    for var; do
	debug '%s: \"%s\"' $var $(eval "echo \$$var")
    done
}
